(function() {
    // replace bindEventListeners
    var proxied = x3dom.X3DCanvas.prototype.bindEventListeners;
    x3dom.X3DCanvas.prototype.bindEventListeners = function() {
    var that = this;
    this.onMouseDown = function(evt) {
        if (!this.isMulti) {
            this.focus();
            this.classList.add('x3dom-canvas-mousedown');
            switch (evt.button) {
                case 0:
                    this.mouse_button = 1;
                    break;
                case 1:
                    this.mouse_button = 4;
                    break;
                case 2:
                    this.mouse_button = 2;
                    break;
                default:
                    this.mouse_button = 0;
                    break;
            }
            if (evt.shiftKey) {
                this.mouse_button = 1;
            }
            if (evt.ctrlKey) {
                this.mouse_button = 4;
            }
            if (evt.altKey) {
                this.mouse_button = 2;
            }
            var pos = this.parent.mousePosition(evt);
            this.mouse_drag_x = pos.x;
            this.mouse_drag_y = pos.y;
            this.mouse_dragging = true;
            this.parent.doc.onMousePress(that.gl, this.mouse_drag_x, this.mouse_drag_y, this.mouse_button);
            this.parent.doc.needRender = true;
        }
    }
    this.onMouseUp = function(evt) {
        if (!this.isMulti) {
            var prev_mouse_button = this.mouse_button;
            this.classList.remove('x3dom-canvas-mousedown');
            this.mouse_button = 0;
            this.mouse_dragging = false;
            this.parent.doc.onMouseRelease(that.gl, this.mouse_drag_x, this.mouse_drag_y, this.mouse_button, prev_mouse_button);
            this.parent.doc.needRender = true;
        }
    }
    this.onMouseOver = function(evt) {
        if (!this.isMulti) {
            this.mouse_button = 0;
            this.mouse_dragging = false;
            this.parent.doc.onMouseOver(that.gl, this.mouse_drag_x, this.mouse_drag_y, this.mouse_button);
            this.parent.doc.needRender = true;
        }
    }
    this.onMouseAlt = function(evt) {
        if (!this.isMulti) {
            this.mouse_button = 0;
            this.mouse_dragging = false;
            this.classList.remove('x3dom-canvas-mousedown');
            this.parent.doc.onMouseOut(that.gl, this.mouse_drag_x, this.mouse_drag_y, this.mouse_button);
            this.parent.doc.needRender = true;
        }
    }
    this.onDoubleClick = function(evt) {
        if (!this.isMulti) {
            this.mouse_button = 0;
            var pos = this.parent.mousePosition(evt);
            this.mouse_drag_x = pos.x;
            this.mouse_drag_y = pos.y;
            this.mouse_dragging = false;
            this.parent.doc.onDoubleClick(that.gl, this.mouse_drag_x, this.mouse_drag_y);
            this.parent.doc.needRender = true;
        }
    }
    this.onMouseMove = function(evt) {
        if (!this.isMulti) {
            var pos = this.parent.mousePosition(evt);
            if (pos.x != that.lastMousePos.x || pos.y != that.lastMousePos.y) {
                that.lastMousePos = pos;
                if (evt.shiftKey) {
                    this.mouse_button = 1;
                }
                if (evt.ctrlKey) {
                    this.mouse_button = 4;
                }
                if (evt.altKey) {
                    this.mouse_button = 2;
                }
                this.mouse_drag_x = pos.x;
                this.mouse_drag_y = pos.y;
                if (this.mouse_dragging) {
                    if (this.mouse_button == 1 && !this.parent.disableLeftDrag || this.mouse_button == 2 && !this.parent.disableRightDrag || this.mouse_button == 4 && !this.parent.disableMiddleDrag) {
                        this.parent.doc.onDrag(that.gl, this.mouse_drag_x, this.mouse_drag_y, this.mouse_button);
                    }
                } else {
                    this.parent.doc.onMove(that.gl, this.mouse_drag_x, this.mouse_drag_y, this.mouse_button);
                }
                this.parent.doc.needRender = true;
                evt.preventDefault();
                evt.stopPropagation();
            }
        }
    }
    this.onDOMMouseScroll = function(evt) {
        if (!this.isMulti) {
            this.focus();
            var originalY = this.parent.mousePosition(evt).y;
            this.mouse_drag_y += 2 * evt.detail;
            this.parent.doc.onWheel(that.gl, this.mouse_drag_x, this.mouse_drag_y, originalY);
            this.parent.doc.needRender = true;
            evt.preventDefault();
            evt.stopPropagation();
        }
    }
    this.onKeyPress = function(evt) {
        if (!this.parent.disableKeys) {
            this.parent.doc.onKeyPress(evt.charCode);
        }
        this.parent.doc.needRender = true;
    }
    this.onMouseWheel = function(evt) {
        if (!this.isMulti) {
            this.focus();
            var originalY = this.parent.mousePosition(evt).y;
            this.mouse_drag_y -= 0.1 * evt.wheelDelta;
            this.parent.doc.onWheel(that.gl, this.mouse_drag_x, this.mouse_drag_y, originalY);
            this.parent.doc.needRender = true;
            evt.preventDefault();
            evt.stopPropagation();
        }
    }
    this.onKeyUp = function(evt) {
        if (!this.parent.disableKeys) {
            this.parent.doc.onKeyUp(evt.keyCode);
        }
        this.parent.doc.needRender = true;
    }
    this.onKeyDown = function(evt) {
        if (!this.parent.disableKeys) {
            this.parent.doc.onKeyDown(evt.keyCode);
        }
        this.parent.doc.needRender = true;
    }
    if (this.canvas !== null && this.gl !== null && this.hasRuntime) {
        this.canvas.mouse_dragging = false;
        this.canvas.mouse_button = 0;
        this.canvas.mouse_drag_x = 0;
        this.canvas.mouse_drag_y = 0;
        this.canvas.isMulti = false;
        this.canvas.oncontextmenu = function(evt) {
            evt.preventDefault();
            evt.stopPropagation();
            return false;
        };
        this.canvas.addEventListener("webglcontextlost", function(event) {
            x3dom.debug.logError("WebGL context lost");
            event.preventDefault();
        }, false);
        this.canvas.addEventListener("webglcontextrestored", function(event) {
            x3dom.debug.logError("recover WebGL state and resources on context lost NYI");
            event.preventDefault();
        }, false);
        this.canvas.addEventListener('mousedown', this.onMouseDown, false);
        this.canvas.addEventListener('mouseup', this.onMouseUp, false);
        this.canvas.addEventListener('mouseover', this.onMouseOver, false);
        this.canvas.addEventListener('mouseout', this.onMouseOut, false);
        this.canvas.addEventListener('dblclick', this.onDoubleClick, false);
        this.canvas.addEventListener('mousemove', this.onMouseMove, false);
        this.canvas.addEventListener('DOMMouseScroll', this.onDOMMouseScroll, false);
        this.canvas.addEventListener('mousewheel', this.onMouseWheel, false);
        this.canvas.addEventListener('keypress', this.onKeyPress, true);
        this.canvas.addEventListener('keyup', this.onKeyUp, true);
        this.canvas.addEventListener('keydown', this.onKeyDown, true);
        var touches = {
            numTouches: 0,
            firstTouchTime: new Date().getTime(),
            firstTouchPoint: new x3dom.fields.SFVec2f(0, 0),
            lastPos: new x3dom.fields.SFVec2f(),
            lastDrag: new x3dom.fields.SFVec2f(),
            lastMiddle: new x3dom.fields.SFVec2f(),
            lastSquareDistance: 0,
            lastAngle: 0,
            lastLayer: [],
            examineNavType: 1,
            calcAngle: function(vector) {
                var rotation = vector.normalize().dot(new x3dom.fields.SFVec2f(1, 0));
                rotation = Math.acos(rotation);
                if (vector.y < 0)
                    rotation = Math.PI + (Math.PI - rotation);
                return rotation;
            },
            disableTouch: this.disableTouch,
            visMarker: this.showTouchpoints,
            visMarkerBag: [],
            visualizeTouches: function(evt) {
                if (!this.visMarker)
                    return;
                var touchBag = [];
                var marker = null;
                for (var i = 0; i < evt.touches.length; i++) {
                    var id = evt.touches[i].identifier || evt.touches[i].streamId;
                    if (!id) id = 0;
                    var index = this.visMarkerBag.indexOf(id);
                    if (index >= 0) {
                        marker = document.getElementById("visMarker" + id);
                        marker.style.left = (evt.touches[i].pageX) + "px";
                        marker.style.top = (evt.touches[i].pageY) + "px";
                    } else {
                        marker = document.createElement("div");
                        marker.appendChild(document.createTextNode("#" + id));
                        marker.id = "visMarker" + id;
                        marker.className = "x3dom-touch-marker";
                        document.body.appendChild(marker);
                        index = this.visMarkerBag.length;
                        this.visMarkerBag[index] = id;
                    }
                    touchBag.push(id);
                }
                for (var j = this.visMarkerBag.length - 1; j >= 0; j--) {
                    var oldId = this.visMarkerBag[j];
                    if (touchBag.indexOf(oldId) < 0) {
                        this.visMarkerBag.splice(j, 1);
                        marker = document.getElementById("visMarker" + oldId);
                        document.body.removeChild(marker);
                    }
                }
            }
        };
        var touchStartHandler = function(evt, doc) {
            var i, pos;
            this.isMulti = true;
            evt.preventDefault();
            touches.visualizeTouches(evt);
            this.focus();
            if (doc == null)
                doc = this.parent.doc;
            pos = this.parent.mousePosition(evt.touches[0]);
            this.mouse_button = 0;
            this.parent.doc.onMove(that.gl, pos.x, pos.y, this.mouse_button);
            if (doc._viewarea._currentInputType == x3dom.InputTypes.INTERACTION) {
                this.mouse_drag_x = pos.x;
                this.mouse_drag_y = pos.y;
                this.mouse_dragging = true;
                this.mouse_button = 1;
                this.parent.doc.onMousePress(that.gl, this.mouse_drag_x, this.mouse_drag_y, this.mouse_button);
            } else {
                var navi = doc._scene.getNavigationInfo();
                switch (navi.getType()) {
                    case "examine":
                        touches.examineNavType = 1;
                        break;
                    case "turntable":
                        touches.examineNavType = 2;
                        break;
                    default:
                        touches.examineNavType = 0;
                        break;
                }
                touches.lastLayer = [];
                for (i = 0; i < evt.touches.length; i++) {
                    pos = this.parent.mousePosition(evt.touches[i]);
                    touches.lastLayer.push([evt.touches[i].identifier, new x3dom.fields.SFVec2f(pos.x, pos.y)]);
                }
                if (touches.numTouches < 1 && evt.touches.length == 1) {
                    touches.numTouches = 1;
                    touches.lastDrag = new x3dom.fields.SFVec2f(evt.touches[0].screenX, evt.touches[0].screenY);
                } else if (touches.numTouches < 2 && evt.touches.length >= 2) {
                    touches.numTouches = 2;
                    var touch0 = new x3dom.fields.SFVec2f(evt.touches[0].screenX, evt.touches[0].screenY);
                    var touch1 = new x3dom.fields.SFVec2f(evt.touches[1].screenX, evt.touches[1].screenY);
                    var distance = touch1.subtract(touch0);
                    var middle = distance.multiply(0.5).add(touch0);
                    var squareDistance = distance.dot(distance);
                    touches.lastMiddle = middle;
                    touches.lastSquareDistance = squareDistance;
                    touches.lastAngle = touches.calcAngle(distance);
                    touches.lastPos = this.parent.mousePosition(evt.touches[0]);
                }
                if (evt.touches.length) {
                    doc._scene.updateVolume();
                    if (touches.examineNavType == 1) {
                        for (i = 0; i < evt.touches.length; i++) {
                            pos = this.parent.mousePosition(evt.touches[i]);
                            doc.onPick(that.gl, pos.x, pos.y);
                            doc._viewarea.prepareEvents(pos.x, pos.y, 1, "onmousedown");
                            doc._viewarea._pickingInfo.lastClickObj = doc._viewarea._pickingInfo.pickObj;
                        }
                    }
                }
            }
            doc.needRender = true;
        };
        var touchMoveHandler = function(evt, doc) {
            evt.preventDefault();
            touches.visualizeTouches(evt);
            if (doc == null)
                doc = this.parent.doc;
            var pos = null;
            var rotMatrix = null;
            var touch0, touch1, distance, middle, squareDistance, deltaMiddle, deltaZoom, deltaMove;
            if (doc._viewarea._currentInputType == x3dom.InputTypes.INTERACTION) {
                    pos = this.parent.mousePosition(evt.touches[0]);
                this.mouse_drag_x = pos.x;
                this.mouse_drag_y = pos.y;
                if (this.mouse_dragging) {
                        this.parent.doc.onDrag(that.gl, this.mouse_drag_x, this.mouse_drag_y, this.mouse_button);
                }
            } else {
              if (touches.examineNavType == 1) {
                if (evt.touches.length == 1) {
                    var currentDrag = new x3dom.fields.SFVec2f(evt.touches[0].screenX, evt.touches[0].screenY);
                    var deltaDrag = currentDrag.subtract(touches.lastDrag);
                    touches.lastDrag = currentDrag;
                    var mx = x3dom.fields.SFMatrix4f.rotationY(deltaDrag.x / 100);
                    var my = x3dom.fields.SFMatrix4f.rotationX(deltaDrag.y / 100);
                    rotMatrix = mx.mult(my);
                    doc.onMoveView(that.gl, evt, touches, null, rotMatrix);
                } else if (evt.touches.length >= 2) {
                    touch0 = new x3dom.fields.SFVec2f(evt.touches[0].screenX, evt.touches[0].screenY);
                    touch1 = new x3dom.fields.SFVec2f(evt.touches[1].screenX, evt.touches[1].screenY);
                    distance = touch1.subtract(touch0);
                    middle = distance.multiply(0.5).add(touch0);
                    squareDistance = distance.dot(distance);
                    deltaMiddle = middle.subtract(touches.lastMiddle);
                    deltaZoom = squareDistance - touches.lastSquareDistance;
                    deltaMove = new x3dom.fields.SFVec3f(deltaMiddle.x / screen.width, -deltaMiddle.y / screen.height, deltaZoom / (screen.width * screen.height * 0.2));
                    var rotation = touches.calcAngle(distance);
                    var angleDelta = touches.lastAngle - rotation;
                    touches.lastAngle = rotation;
                    rotMatrix = x3dom.fields.SFMatrix4f.rotationZ(angleDelta);
                    touches.lastMiddle = middle;
                    touches.lastSquareDistance = squareDistance;
                    doc.onMoveView(that.gl, evt, touches, deltaMove, rotMatrix);
                }
              } else if (evt.touches.length) {
                if (touches.examineNavType == 2 && evt.touches.length >= 2) {
                    touch0 = new x3dom.fields.SFVec2f(evt.touches[0].screenX, evt.touches[0].screenY);
                    touch1 = new x3dom.fields.SFVec2f(evt.touches[1].screenX, evt.touches[1].screenY);
                    distance = touch1.subtract(touch0);
                    squareDistance = distance.dot(distance);
                    deltaZoom = (squareDistance - touches.lastSquareDistance) / (0.1 * (screen.width + screen.height));
                    touches.lastPos.y += deltaZoom;
                    touches.lastSquareDistance = squareDistance;
                    doc.onDrag(that.gl, touches.lastPos.x, touches.lastPos.y, 2);
                }
              }
            }
            doc.needRender = true;
        };
        var touchEndHandler = function(evt, doc) {
            this.isMulti = false;
            evt.preventDefault();
            touches.visualizeTouches(evt);
            if (doc == null)
                doc = this.parent.doc;
            doc._viewarea._isMoving = false;
            if (touches.numTouches == 2 && evt.touches.length == 1)
                touches.lastDrag = new x3dom.fields.SFVec2f(evt.touches[0].screenX, evt.touches[0].screenY);
            var dblClick = false;
            if (evt.touches.length < 2) {
                if (touches.numTouches == 1)
                    dblClick = true;
                touches.numTouches = evt.touches.length;
            }
            if (doc._viewarea._currentInputType == x3dom.InputTypes.INTERACTION) {
                this.classList.remove('x3dom-canvas-mousedown');
                this.mouse_button = 0;
                this.mouse_dragging = false;
                this.parent.doc.onMouseRelease(that.gl, this.mouse_drag_x, this.mouse_drag_y, this.mouse_button, 0);
                this.parent.doc.needRender = true;
        } else {
          if (touches.examineNavType == 1) {
                for (var i = 0; i < touches.lastLayer.length; i++) {
                    var pos = touches.lastLayer[i][1];
                    doc.onPick(that.gl, pos.x, pos.y);
                    if (doc._scene._vf.pickMode.toLowerCase() !== "box") {
                        doc._viewarea.prepareEvents(pos.x, pos.y, 1, "onmouseup");
                        doc._viewarea._pickingInfo.lastClickObj = doc._viewarea._pickingInfo.pickObj;
                        if (doc._viewarea._pickingInfo.pickObj && doc._viewarea._pickingInfo.pickObj === doc._viewarea._pickingInfo.lastClickObj) {
                            doc._viewarea.prepareEvents(pos.x, pos.y, 1, "onclick");
                        }
                    } else {
                        var line = doc._viewarea.calcViewRay(pos.x, pos.y);
                        var isect = doc._scene.doIntersect(line);
                        var obj = line.hitObject;
                        if (isect && obj) {
                            doc._viewarea._pick.setValues(line.hitPoint);
                            doc._viewarea.checkEvents(obj, pos.x, pos.y, 1, "onclick");
                            x3dom.debug.logInfo("Hit '" + obj._xmlNode.localName + "/ " +
                                obj._DEF + "' at pos " + doc._viewarea._pick);
                        }
                    }
                }
                if (dblClick) {
                    var now = new Date().getTime();
                    var dist = touches.firstTouchPoint.subtract(touches.lastDrag).length();
                    if (dist < 18 && now - touches.firstTouchTime < 180)
                        doc.onDoubleClick(that.gl, 0, 0);
                    touches.firstTouchTime = now;
                    touches.firstTouchPoint = touches.lastDrag;
                }
            } else if (touches.lastLayer.length) {
                pos = touches.lastLayer[0][1];
                doc.onMouseRelease(that.gl, pos.x, pos.y, 0, 1);
            }
          }
            doc.needRender = true;
        };
        if (!this.disableTouch) {
            this.canvas.addEventListener('touchstart', touchStartHandler, true);
            this.canvas.addEventListener('touchmove', touchMoveHandler, true);
            this.canvas.addEventListener('touchend', touchEndHandler, true);
        }
    }
}
})();
